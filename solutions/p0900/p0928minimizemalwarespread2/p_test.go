package p0928minimizemalwarespread2

import (
	"fmt"
	"testing"

	"github.com/sebnyberg/leetcode"
	"github.com/stretchr/testify/require"
)

func Test_minMalwareSpread(t *testing.T) {
	for i, tc := range []struct {
		graph   [][]int
		initial []int
		want    int
	}{
		{
			leetcode.ParseMatrix("[[1,1,0],[1,1,0],[0,0,1]]"),
			[]int{0, 1},
			0,
		},
		{
			leetcode.ParseMatrix("[[1,1,0],[1,1,1],[0,1,1]]"),
			[]int{0, 1},
			1,
		},
		{
			leetcode.ParseMatrix("[[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]]"),
			[]int{0, 1},
			1,
		},
	} {
		t.Run(fmt.Sprint(i), func(t *testing.T) {
			require.Equal(t, tc.want, minMalwareSpread(tc.graph, tc.initial))
		})
	}
}

func minMalwareSpread(graph [][]int, initial []int) int {
	// If a node is removed, then it will reduce the total amount of infection
	// by an amount equal to the number of nodes only reachable from that node
	// (out of the nodes in the infected list).
	//
	// We can establish the components that exist with bfs, carefully avoiding
	// infected nodes.
	n := len(graph)
	infected := make([]bool, n)
	for i := range initial {
		infected[initial[i]] = true
	}

	// adjacency lists are much easier to work with, and using a word to store 1
	// or 0 is terribly inefficient
	adj := make([][]uint16, n)
	for i := range adj {
		adj[i] = make([]uint16, 0)
	}
	for i := range graph {
		for j, v := range graph[i] {
			if v == 1 && i != j {
				adj[i] = append(adj[i], uint16(j))
				adj[j] = append(adj[j], uint16(i))
			}
		}
	}

	// component[i] = component (index) for node i
	// infected nodes are not part of components
	component := make([]int, n)
	for i := range component {
		component[i] = -1
	}
	// size[i] = size of component i (number of nodes)
	size := []int{}

	// Used for BFS
	curr := []uint16{}
	next := []uint16{}

	// Number of components
	var ncomp int
	for i := range adj {
		if component[i] != -1 || infected[i] {
			continue
		}
		curr = curr[:0]
		curr = append(curr, uint16(i))
		component[i] = ncomp
		size = append(size, 1)
		for len(curr) > 0 {
			next = next[:0]
			for _, i := range curr {
				for _, j := range adj[i] {
					if infected[j] || component[j] != -1 {
						continue
					}
					component[j] = ncomp
					size[ncomp]++
					next = append(next, j)
				}
			}
			curr, next = next, curr
		}
		ncomp++
	}

	// For each infected node, add it to adjacent components.
	ninfected := make([]int, ncomp)
	seen := make([]bool, ncomp)
	for _, i := range initial {
		for j := range seen {
			seen[j] = false
		}
		for _, j := range adj[i] {
			if component[j] < 0 || seen[component[j]] {
				continue
			}
			ninfected[component[j]]++
			seen[component[j]] = true
		}
	}

	// For each infected node, calculate size of adjacent components which are
	// only connected to one infected node. This is the amount of nodes that
	// would go uninfected (excluding the node itself) had it been removed from
	// the graph.
	var maxSum int
	var res int
	for _, i := range initial {
		for j := range seen {
			seen[j] = false
		}
		sum := 1
		for _, j := range adj[i] {
			if component[j] < 0 || seen[component[j]] || ninfected[component[j]] > 1 {
				continue
			}
			seen[component[j]] = true
			sum += size[component[j]]
		}
		if sum > maxSum || (sum == maxSum && i < res) {
			res = i
			maxSum = sum
		}
	}
	return res
}
