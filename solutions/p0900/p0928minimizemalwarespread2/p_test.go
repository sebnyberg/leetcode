package p0928minimizemalwarespread2

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/require"
)

func Test_minMalwareSpread(t *testing.T) {
	for _, tc := range []struct {
		graph   [][]int
		initial []int
		want    int
	}{
		{[][]int{
			{1, 1, 0, 0, 0, 0, 0, 0, 0, 0},
			{1, 1, 0, 0, 0, 0, 0, 0, 0, 0},
			{0, 0, 1, 0, 0, 0, 0, 0, 0, 0},
			{0, 0, 0, 1, 0, 0, 1, 0, 0, 1},
			{0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 1, 0, 0, 0, 0},
			{0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
			{0, 0, 0, 1, 0, 0, 0, 0, 0, 1},
		}, []int{2, 1, 9}, 9},
		{[][]int{
			{1, 0, 0, 0, 0, 0, 0, 0, 0},
			{0, 1, 0, 0, 0, 0, 0, 0, 1},
			{0, 0, 1, 0, 0, 0, 0, 0, 0},
			{0, 0, 0, 1, 0, 0, 0, 0, 1},
			{0, 0, 0, 0, 1, 0, 1, 1, 1},
			{0, 0, 0, 0, 0, 1, 0, 0, 1},
			{0, 0, 0, 0, 1, 0, 1, 1, 0},
			{0, 0, 0, 0, 1, 0, 1, 1, 0},
			{0, 1, 0, 1, 1, 1, 0, 0, 1},
		}, []int{8, 4, 2, 0}, 8},
		{[][]int{{1, 1, 0, 0}, {1, 1, 1, 0}, {0, 1, 1, 1}, {0, 0, 1, 1}}, []int{0, 1}, 1},
		{[][]int{{1, 1, 0, 0}, {1, 1, 1, 0}, {0, 1, 1, 1}, {0, 0, 1, 1}}, []int{0, 1}, 1},
		{[][]int{{1, 1, 1, 0}, {1, 1, 0, 0}, {1, 0, 1, 0}, {0, 0, 0, 1}}, []int{3, 2}, 2},
		{[][]int{{1, 1, 0}, {1, 1, 1}, {0, 1, 1}}, []int{0, 1}, 1},
		{[][]int{{1, 1, 0}, {1, 1, 0}, {0, 0, 1}}, []int{0, 1}, 0},
	} {
		t.Run(fmt.Sprintf("%+v", tc.graph), func(t *testing.T) {
			require.Equal(t, tc.want, minMalwareSpread(tc.graph, tc.initial))
		})
	}
}

func minMalwareSpread(graph [][]int, initial []int) int {
	n := len(graph)
	dsu := newDSU(n)

	// Create a list of whether a node is infected given the
	// initial infected list. Infected nodes will not be added
	// when creating components of the graph
	infected := make([]bool, n)
	for _, u := range initial {
		infected[u] = true
	}

	// Connect graph without infected nodes
	for u := range graph {
		if infected[u] {
			continue
		}
		for v, val := range graph[u] {
			if !infected[v] && val == 1 {
				dsu.union(u, v)
			}
		}
	}

	// Map each infected node to its nearby components
	// Since components have a shared root in each component,
	// the map will ensure that each nearby component is added
	// only once
	nearbyComponents := make(map[int]map[int]struct{})
	infectedPerComponent := make([]int, n)
	for _, u := range initial {
		nearbyComponents[u] = make(map[int]struct{})
		for v := range graph {
			if !infected[v] && graph[u][v] == 1 {
				nearbyComponents[u][dsu.find(v)] = struct{}{}
			}
		}
		for componentRoot := range nearbyComponents[u] {
			infectedPerComponent[componentRoot]++
		}
	}

	maxSize := -1
	maxIndex := -1
	for u, nearby := range nearbyComponents {
		size := 0
		for componentRoot := range nearby {
			if infectedPerComponent[componentRoot] == 1 {
				size += dsu.sizes[componentRoot]
			}
		}
		if size > maxSize || (size == maxSize && u < maxIndex) {
			maxIndex = u
			maxSize = size
		}
	}
	return maxIndex
}

type dsu struct {
	parent []int
	sizes  []int
}

func newDSU(n int) dsu {
	dsu := dsu{
		parent: make([]int, n),
		sizes:  make([]int, n),
	}
	for i := range dsu.parent {
		dsu.parent[i] = i
		dsu.sizes[i] = 1
	}
	return dsu
}

func (d *dsu) find(x int) int {
	p := d.parent[x]
	if p == x {
		return x
	}
	// Path compression
	root := d.find(p)
	d.parent[x] = root
	return root
}

func (d *dsu) union(x, y int) {
	x = d.find(x)
	y = d.find(y)
	if x == y {
		return
	}
	if d.sizes[y] > d.sizes[x] {
		x, y = y, x
	}
	d.parent[y] = x
	d.sizes[x] += d.sizes[y]
}
