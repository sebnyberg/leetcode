package p0928minimizemalwarespread

import (
	"fmt"
	"sort"
	"testing"

	"github.com/stretchr/testify/require"
)

func Test_minMalwareSpread(t *testing.T) {
	for _, tc := range []struct {
		graph   [][]int
		initial []int
		want    int
	}{

		{[][]int{
			{1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1},
			{0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0},
			{0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0},
			{0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0},
			{1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0},
			{0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0},
			{0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0},
			{0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0},
			{0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0},
			{0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0},
			{1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}},
			[]int{7, 8, 6, 2, 3}, 2},
		{[][]int{
			{1, 1, 0, 0, 0, 0, 0, 0, 0, 0},
			{1, 1, 0, 0, 0, 0, 0, 0, 0, 0},
			{0, 0, 1, 0, 0, 0, 0, 0, 0, 0},
			{0, 0, 0, 1, 0, 0, 1, 0, 0, 1},
			{0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
			{0, 0, 0, 0, 0, 1, 0, 0, 0, 0},
			{0, 0, 0, 1, 0, 0, 1, 0, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 1, 0, 0},
			{0, 0, 0, 0, 0, 0, 0, 0, 1, 0},
			{0, 0, 0, 1, 0, 0, 0, 0, 0, 1},
		}, []int{2, 1, 9}, 9},
		{[][]int{{1, 1, 0}, {1, 1, 0}, {0, 0, 1}}, []int{0, 1, 2}, 2},
		{[][]int{{1, 1, 0}, {1, 1, 0}, {0, 0, 1}}, []int{0, 1}, 0},
		{[][]int{{1, 0, 0}, {0, 1, 0}, {0, 0, 1}}, []int{0, 2}, 0},
		{[][]int{{1, 1, 1}, {1, 1, 1}, {1, 1, 1}}, []int{1, 2}, 1},
	} {
		t.Run(fmt.Sprintf("%+v", tc.graph), func(t *testing.T) {
			require.Equal(t, tc.want, minMalwareSpread(tc.graph, tc.initial))
		})
	}
}

func minMalwareSpread(graph [][]int, initial []int) int {
	n := len(graph)
	dsu := newDSU(n)

	// Connect all nodes together in the DSU
	for i := range graph {
		for j, v := range graph[i] {
			if v == 1 {
				dsu.union(i, j)
			}
		}
	}

	// Map each infected node to its group
	type groupInfections struct {
		size            int
		infectedIndices []int
	}
	infectedGroup := make(map[int]*groupInfections, len(initial))
	for i := range initial {
		root := dsu.find(initial[i])
		if _, exists := infectedGroup[root]; !exists {
			infectedGroup[root] = &groupInfections{
				size:            dsu.sizes[root],
				infectedIndices: make([]int, 0),
			}
		}
		infectedGroup[root].infectedIndices = append(infectedGroup[root].infectedIndices, initial[i])
	}

	maxClean := -1
	alternatives := make([]int, 0)
	for _, g := range infectedGroup {
		ninfected := len(g.infectedIndices)
		switch {
		case ninfected == 1:
			switch {
			case g.size > maxClean:
				maxClean = g.size
				alternatives = []int{g.infectedIndices[0]}
			case g.size == maxClean:
				alternatives = append(alternatives, g.infectedIndices[0])
			}
		case maxClean == -1:
			alternatives = append(alternatives, g.infectedIndices...)
		}
	}

	sort.Ints(alternatives)
	return alternatives[0]
}

type dsu struct {
	parent []int
	sizes  []int
}

func newDSU(n int) dsu {
	dsu := dsu{
		parent: make([]int, n),
		sizes:  make([]int, n),
	}
	for i := range dsu.parent {
		dsu.parent[i] = i
		dsu.sizes[i] = 1
	}
	return dsu
}

func (d *dsu) find(x int) int {
	p := d.parent[x]
	if p == x {
		return x
	}
	// Path compression
	root := d.find(p)
	d.parent[x] = root
	return root
}

func (d *dsu) union(x, y int) {
	x = d.find(x)
	y = d.find(y)
	if x == y {
		return
	}
	if d.sizes[y] > d.sizes[x] {
		x, y = y, x
	}
	d.parent[y] = x
	d.sizes[x] += d.sizes[y]
}
